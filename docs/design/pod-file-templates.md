# Pod File Template System Design

## Problem Statement

During the ebook stack deployment session (2026-02-03), we needed to create a `calibredb` wrapper script inside the Calibre-Web pod. This required multiple `kubectl exec` commands outside the MCP tooling.

A raw `write_pod_file` tool would solve this, but **exposing arbitrary file write to an AI is essentially remote code execution** - writing to cron, bashrc, or scripts enables code execution.

## Solution: Template-Based Approach

Instead of raw file write, we provide **predefined templates** that:
- Are code-reviewed and version-controlled
- Define fixed target paths (no user control over where files go)
- Accept only validated parameters
- Are scoped to specific namespaces

The AI can invoke templates with parameters, but cannot write arbitrary content.

## Template Definition Structure

```typescript
// src/templates/pod-files.ts

interface PodFileTemplate {
  description: string;
  targetNamespaces: string[];     // Which namespaces this template can be used in
  targetPath: string;             // Fixed destination path
  mode: string;                   // File permissions (e.g., '755', '644')
  append?: boolean;               // Append to file instead of overwrite
  parameters: {
    [name: string]: {
      type: 'string' | 'number';
      pattern?: RegExp;           // Validation regex for strings
      enum?: string[];            // Allowed values (whitelist)
      default?: string | number;
      required?: boolean;
      description: string;
    }
  };
  content: string;                // Template content with {{placeholder}} syntax
}
```

## Example Templates

### 1. Calibredb Wrapper Script

```typescript
'calibredb-wrapper': {
  description: 'Wrapper script for calibredb CLI in Calibre-Web pods',
  targetNamespaces: ['media'],
  targetPath: '/scripts/calibredb-wrapper.sh',
  mode: '755',
  parameters: {
    libraryPath: {
      type: 'string',
      pattern: /^\/[a-zA-Z0-9\/_-]+$/,
      default: '/books',
      description: 'Path to Calibre library'
    },
    calibredbBinary: {
      type: 'string',
      pattern: /^\/[a-zA-Z0-9\/_-]+$/,
      default: '/usr/bin/calibredb',
      description: 'Path to calibredb binary'
    }
  },
  content: `#!/bin/bash
# Calibredb wrapper for Calibre-Web
# Generated by MCP homelab

LIBRARY="{{libraryPath}}"
CALIBREDB="{{calibredbBinary}}"

exec "$CALIBREDB" --library-path="$LIBRARY" "$@"
`
}
```

### 2. Pi-hole Custom DNS Entry

```typescript
'pihole-custom-list': {
  description: 'Add entries to Pi-hole custom DNS list',
  targetNamespaces: ['pihole'],
  targetPath: '/etc/pihole/custom.list',
  mode: '644',
  append: true,
  parameters: {
    ip: {
      type: 'string',
      pattern: /^(\d{1,3}\.){3}\d{1,3}$/,
      required: true,
      description: 'IP address'
    },
    hostname: {
      type: 'string',
      pattern: /^[a-zA-Z0-9][a-zA-Z0-9.-]+$/,
      required: true,
      description: 'Hostname to resolve'
    }
  },
  content: `{{ip}} {{hostname}}
`
}
```

### 3. SQLite Backup Script

```typescript
'sqlite-backup': {
  description: 'Create a backup of an SQLite database before modifications',
  targetNamespaces: ['media', 'pihole'],
  targetPath: '/tmp/backup-db.sh',
  mode: '755',
  parameters: {
    dbPath: {
      type: 'string',
      pattern: /^\/[a-zA-Z0-9\/_.-]+\.db$/,
      required: true,
      description: 'Path to SQLite database file'
    }
  },
  content: `#!/bin/bash
# Backup SQLite database before modifications
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
DB="{{dbPath}}"
BACKUP="\${DB}.\${TIMESTAMP}.bak"
cp "$DB" "$BACKUP"
echo "Backed up to $BACKUP"
`
}
```

## MCP Tools

### list_pod_file_templates

Discovery tool that returns available templates and their parameters.

```typescript
{
  name: 'list_pod_file_templates',
  description: 'List available pod file templates and their parameters',
  inputSchema: { type: 'object', properties: {} },
  handler: async () => {
    return Object.entries(podFileTemplates).map(([name, tmpl]) => ({
      name,
      description: tmpl.description,
      targetPath: tmpl.targetPath,
      namespaces: tmpl.targetNamespaces,
      parameters: Object.entries(tmpl.parameters).map(([param, def]) => ({
        name: param,
        type: def.type,
        required: def.required ?? false,
        default: def.default,
        description: def.description
      }))
    }));
  }
}
```

### apply_pod_file_template

Applies a template to a pod with validated parameters.

```typescript
{
  name: 'apply_pod_file_template',
  description: 'Apply a predefined file template to a pod',
  inputSchema: {
    type: 'object',
    properties: {
      namespace: { type: 'string' },
      pod: { type: 'string', description: 'Pod name (supports fuzzy match)' },
      template: { type: 'string' },
      parameters: { type: 'object' }
    },
    required: ['namespace', 'pod', 'template']
  },
  handler: async ({ namespace, pod, template, parameters = {} }) => {
    // 1. Lookup template
    // 2. Validate namespace against allowlist
    // 3. Validate all parameters against patterns/enums
    // 4. Render template with parameters
    // 5. Write to pod via exec (echo/cat)
    // 6. Return success with path written
  }
}
```

## Security Model

| Threat | Mitigation |
|--------|------------|
| Arbitrary file write | Impossible - only predefined templates exist |
| Path traversal | Paths are hardcoded in template definitions |
| Command injection in scripts | Template content is code-reviewed before merge |
| Parameter injection | Strict regex/enum validation per parameter |
| Write to wrong namespace | Namespace allowlist enforced per template |
| Overwrite critical files | Template paths are explicit and reviewed |

### What the AI CANNOT Do

- Write to arbitrary paths
- Write arbitrary content
- Write to namespaces not in the template's allowlist
- Bypass parameter validation
- Create new templates (requires code change + review)

### What the AI CAN Do

- Discover available templates
- Apply templates with validated parameters
- Help diagnose which template to use for a situation

## Template Categories

### Wrapper Scripts
- `calibredb-wrapper` - Calibre database CLI wrapper
- `ffmpeg-wrapper` - FFmpeg with common presets
- `sqlite3-wrapper` - SQLite CLI wrapper

### Config Patches
- `pihole-custom-list` - Add DNS entries
- `nginx-proxy-header` - Add headers to nginx config

### Diagnostic Scripts
- `sqlite-backup` - Backup database before edits
- `fix-permissions` - Fix media file permissions
- `check-disk-usage` - Disk usage report
- `dump-environment` - Dump env vars for debugging

### Repair Scripts
- `clear-app-cache` - Clear application cache
- `restart-internal-service` - Restart service within container

## Implementation Plan

### Files to Create

1. **src/templates/pod-files.ts** - Template definitions
2. **src/tools/pod-files.ts** - MCP tool implementations

### Files to Modify

1. **src/tools/index.ts** - Register new tools
2. **CLAUDE.md** - Document new tools and security model

### No RBAC Changes Needed

Uses existing `pods/exec` permission to write files via `cat > path` or similar.

## Adding New Templates

When a recurring issue is identified:

1. Developer creates template in `src/templates/pod-files.ts`
2. PR with code review ensures template is safe
3. Merge and deploy new MCP version
4. AI can now use the new template

This keeps humans in the loop for **what** can be written, while the AI handles **when** and **with what parameters**.
